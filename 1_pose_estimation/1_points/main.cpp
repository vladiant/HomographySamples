#include <iostream>
#include <opencv2/calib3d.hpp>
#include <opencv2/core.hpp>
#include <opencv2/highgui.hpp>
#include <opencv2/imgproc.hpp>

using namespace std;
using namespace cv;

namespace {

void poseEstimationFromCoplanarPoints() {
  vector<Point2f> corners{
      {188.822, 130.66},  {223.338, 127.151}, {260.473, 123.582},
      {299.499, 120.18},  {340.195, 117.354}, {382.375, 114.458},
      {425.859, 112.07},  {470.291, 110.184}, {514.705, 109.695},
      {185.622, 168.081}, {220.935, 166.016}, {258.614, 163.079},
      {298.213, 160.432}, {339.462, 158.47},  {382.706, 156.369},
      {427.029, 154.504}, {472.273, 153.439}, {517.599, 152.216},
      {183.416, 207.568}, {218.698, 205.87},  {256.986, 204.241},
      {297.181, 202.884}, {338.935, 201.476}, {382.803, 200.045},
      {427.772, 199.089}, {473.983, 198.077}, {519.722, 197.178},
      {181.356, 247.556}, {217.334, 246.9},   {255.479, 246.529},
      {296.23, 246.004},  {338.473, 245.627}, {382.876, 245.288},
      {428.536, 244.521}, {475.061, 244.327}, {520.766, 243.639},
      {180.276, 287.895}, {216.374, 288.47},  {254.928, 289.641},
      {295.373, 290.282}, {337.948, 290.643}, {382.716, 291.366},
      {428.574, 291.504}, {475.384, 291.4},   {521.752, 290.644},
      {179.531, 328.171}, {215.409, 330.314}, {253.875, 332.292},
      {294.547, 334.368}, {337.596, 335.849}, {382.449, 337.03},
      {428.002, 338.092}, {475.043, 338.106}, {521.907, 338.128},
  };

  const int maxRows = std::max_element(corners.begin(), corners.end(),
                                       [](const Point2f &a, const Point2f &b) {
                                         return a.y < b.y;
                                       })
                          ->y;

  const int maxCols = std::max_element(corners.begin(), corners.end(),
                                       [](const Point2f &a, const Point2f &b) {
                                         return a.x < b.x;
                                       })
                          ->x;

  Mat img_pose{maxRows, maxCols, CV_8UC3, Scalar(0, 0, 0)};

  const vector<Point3f> objectPoints{
      {0, 0, 0},         {0.025, 0, 0},    {0.05, 0, 0},      {0.075, 0, 0},
      {0.1, 0, 0},       {0.125, 0, 0},    {0.15, 0, 0},      {0.175, 0, 0},
      {0.2, 0, 0},       {0, 0.025, 0},    {0.025, 0.025, 0}, {0.05, 0.025, 0},
      {0.075, 0.025, 0}, {0.1, 0.025, 0},  {0.125, 0.025, 0}, {0.15, 0.025, 0},
      {0.175, 0.025, 0}, {0.2, 0.025, 0},  {0, 0.05, 0},      {0.025, 0.05, 0},
      {0.05, 0.05, 0},   {0.075, 0.05, 0}, {0.1, 0.05, 0},    {0.125, 0.05, 0},
      {0.15, 0.05, 0},   {0.175, 0.05, 0}, {0.2, 0.05, 0},    {0, 0.075, 0},
      {0.025, 0.075, 0}, {0.05, 0.075, 0}, {0.075, 0.075, 0}, {0.1, 0.075, 0},
      {0.125, 0.075, 0}, {0.15, 0.075, 0}, {0.175, 0.075, 0}, {0.2, 0.075, 0},
      {0, 0.1, 0},       {0.025, 0.1, 0},  {0.05, 0.1, 0},    {0.075, 0.1, 0},
      {0.1, 0.1, 0},     {0.125, 0.1, 0},  {0.15, 0.1, 0},    {0.175, 0.1, 0},
      {0.2, 0.1, 0},     {0, 0.125, 0},    {0.025, 0.125, 0}, {0.05, 0.125, 0},
      {0.075, 0.125, 0}, {0.1, 0.125, 0},  {0.125, 0.125, 0}, {0.15, 0.125, 0},
      {0.175, 0.125, 0}, {0.2, 0.125, 0},
  };

  vector<Point2f> objectPointsPlanar;
  for (size_t i = 0; i < objectPoints.size(); i++) {
    objectPointsPlanar.push_back(Point2f(objectPoints[i].x, objectPoints[i].y));
  }

  std::vector<double> imgPoints{535.915733961632,
                                0,
                                342.2831547330837,
                                0,
                                535.915733961632,
                                235.5708290978817,
                                0,
                                0,
                                1};
  const cv::Mat1d cameraMatrix{3, 3, imgPoints.data()};

  std::vector<double> distCoeffsVec{-0.2663726090966068, -0.03858889892230465,
                                    0.001783194704285296,
                                    -0.0002812210044111547, 0.2383915308087849};
  const cv::Mat1d distCoeffs{5, 1, distCoeffsVec.data()};

  vector<Point2f> imagePoints;
  undistortPoints(corners, imagePoints, cameraMatrix, distCoeffs);

  // const vector<Point2f> imagePoints{
  //     {-0.296742, -0.203127},    {-0.227869, -0.207904},
  //     {-0.155646, -0.213216},    {-0.0810593, -0.218761},
  //     {-0.0039383, -0.22386},    {0.0760872, -0.229906},
  //     {0.15959, -0.235942},      {0.247051, -0.242179},
  //     {0.337874, -0.246954},     {-0.301049, -0.129903},
  //     {-0.230873, -0.132473},    {-0.158024, -0.137004},
  //     {-0.082858, -0.141333},    {-0.00529064, -0.144791},
  //     {0.0760482, -0.149039},    {0.160364, -0.153478},
  //     {0.248511, -0.15716},      {0.340351, -0.162065},
  //     {-0.304197, -0.0537989},   {-0.234247, -0.0564051},
  //     {-0.160425, -0.0589801},   {-0.0844152, -0.0611998},
  //     {-0.00625462, -0.0637109}, {0.0758385, -0.0665072},
  //     {0.160898, -0.0687137},    {0.250414, -0.0714085},
  //     {0.342545, -0.0743361},    {-0.308053, 0.02277},
  //     {-0.236664, 0.0213576},    {-0.163117, 0.0205444},
  //     {-0.0861001, 0.0194922},   {-0.00710978, 0.0187644},
  //     {0.075868, 0.0181501},     {0.162108, 0.0167729},
  //     {0.252108, 0.0165085},     {0.344043, 0.0153322},
  //     {-0.310995, 0.100258},     {-0.239113, 0.100346},
  //     {-0.164564, 0.101799},     {-0.0879193, 0.102513},
  //     {-0.00810632, 0.102999},   {0.075763, 0.104513},
  //     {0.162613, 0.10533},       {0.25345, 0.106163},
  //     {0.34708, 0.106252},       {-0.314387, 0.178655},
  //     {-0.242473, 0.180919},     {-0.167592, 0.183258},
  //     {-0.0900288, 0.186276},    {-0.00881418, 0.188726},
  //     {0.0757698, 0.191288},     {0.162669, 0.194416},
  //     {0.254669, 0.196477},      {0.350192, 0.199614},
  // };

  Mat H = findHomography(objectPointsPlanar, imagePoints);
  cout << "H:\n" << H << endl;

  // Normalization to ensure that ||c1|| = 1
  double norm = sqrt(H.at<double>(0, 0) * H.at<double>(0, 0) +
                     H.at<double>(1, 0) * H.at<double>(1, 0) +
                     H.at<double>(2, 0) * H.at<double>(2, 0));
  H /= norm;
  Mat c1 = H.col(0);
  Mat c2 = H.col(1);
  Mat c3 = c1.cross(c2);
  Mat tvec = H.col(2);
  Mat R(3, 3, CV_64F);
  for (int i = 0; i < 3; i++) {
    R.at<double>(i, 0) = c1.at<double>(i, 0);
    R.at<double>(i, 1) = c2.at<double>(i, 0);
    R.at<double>(i, 2) = c3.at<double>(i, 0);
  }
  cout << "R (before polar decomposition):\n"
       << R << "\ndet(R): " << determinant(R) << endl;

  Mat W, U, Vt;
  SVDecomp(R, W, U, Vt);
  R = U * Vt;
  cout << "R (after polar decomposition):\n"
       << R << "\ndet(R): " << determinant(R) << endl;

  Mat rvec;
  Rodrigues(R, rvec);
  cout << "rvec:\n" << rvec << endl;
  cout << "tvec:\n" << tvec << endl;

  drawFrameAxes(
      img_pose, cameraMatrix, distCoeffs, rvec, tvec,
      *std::max_element(tvec.begin<double>(), tvec.end<double>()) / 3.0);
  imshow("Pose from coplanar points", img_pose);
  waitKey();
}

}  // namespace

int main(int argc, char *argv[]) {
  poseEstimationFromCoplanarPoints();
  return 0;
}
